OP_NOP
OP_LENGTH           r, r
OP_NEG              r, r
OP_POS              r, r
OP_BITNOT           r, r
OP_NOT              r
OP_MUL              r, r, rk    // commutative, can be swapped
OP_DIV              r, rk, rk
OP_INTDIV           r, rk, rk
OP_MOD              r, rk, rk
OP_ADD              r, r, rk    // commutative, can be swapped
OP_SUB              r, rk, rk
OP_CONCAT           r, rk, rk
OP_LSHIFT           r, rk, rk
OP_RSHIFT           r, rk, rk
OP_ASHIFT           r, rk, rk
OP_BITAND           r, r, rk    // commutative, can be swapped
OP_BITXOR           r, r, rk    // commutative, can be swapped
OP_BITOR            r, r, rk    // commutative, can be swapped
OP_MULI             r, r, i
OP_ADDI             r, r, i
OP_MOVE             r, r
OP_SWAP             r, r
OP_NULL             r           // sets r to null
OP_K                r           // loads constant
OP_TRUE_SKIP        r           // sets r to true, skips next instruction.
OP_TRUE             r           // sets r to true
OP_FALSE            r           // sets r to false
OP_EQ               r, rk       // followed by OP_JUMP
OP_NE               r, rk       // followed by OP_JUMP
OP_LT               r, rk       // followed by OP_JUMP
OP_LE               r, rk       // followed by OP_JUMP
OP_GT               r, rk       // followed by OP_JUMP
OP_GE               r, rk       // followed by OP_JUMP
OP_IS               r, r        // followed by OP_JUMP
OP_GET_GLOBAL       r, [key]
OP_GET_UPVAL        r, [upval]
OP_SET_UPVAL        r, [upval]
OP_GET_KEY          r, r, [key]
OP_SET_KEY          r, r, [key]
OP_GET_INDEX        r, rk, rk
OP_SET_INDEX        r, rk, rk
OP_SUPER            r, r
OP_APPEND           r, rk
OP_NEW_ARRAY        r
OP_NEW_TABLE        r
OP_NEW_FUNCTION     r, [function]
OP_NEW_OBJECT       r, r
OP_CALL
OP_YCALL
OP_YIELD
OP_VARARG
OP_UNPACK
OP_EXTEND
OP_CLOSE
OP_FOR_STEP         r, [addr]   // r[ 0..2 ] = step r[ 0..2 ], branch if limit reached
OP_FOR_EGEN         r, r        // r[ 0..1 ] = make_generator r
OP_FOR_EACH         r, [addr]   // r[ 0..1 ] = generate r[ 0..1 ], branch if no more values
OP_FOR_EVAL         r, r, i     // r = generator result i
OP_JUMP             [addr]      // jump
OP_JUMP [cond]      r, [addr]   // jump if r is true/false/zero/nonzero

