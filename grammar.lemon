//
//  grammar.lemon
//
//  Created by Edmund Kapusniak on 28/09/2019.
//  Copyright Â© 2019 Edmund Kapusniak.
//
//  Licensed under the MIT License. See LICENSE file in the project root for
//  full license information.
//

%include
{
#include <assert.h>
#include "lexer.h"
#include "parser.h"

using namespace kf;

enum expr_kind
{
    EXPR_NONE,      // Empty expression list.
    EXPR_NAME,      // name
    EXPR_LVAL,      // name.key / name[ index ]
    EXPR_CALL,      // name( args )
    EXPR_FULL,      // any other expression
    EXPR_NAME_LIST, // name, name
    EXPR_LVAL_LIST, // name, name.key, expr(x)[ index ]
    EXPR_FULL_LIST, // any other expression list
    EXPR_UNPACK,    // expression list with ... at end
};

struct expr_type
{
    expr_kind kind;
    size_t index;
};

}


%name KenafParse
%token_prefix TOKEN_
%extra_argument { parser* p }
%token_type { token }
%token_destructor { (void)p; }
%syntax_error { p->syntax_error( TOKEN ); }
%default_type { size_t }


// ( expr )( expr ) is ambiguous, resolve as a function call.

%nonassoc PREFER_CALL .
%nonassoc LPN .


// SCRIPT

script ::= block .


// STATEMENTS

block ::= stmt_list .
block ::= stmt_list last_stmt .

stmt_list ::= .
stmt_list ::= stmt_list stmt .
stmt_list ::= stmt_list stmt SEMICOLON .
stmt_list ::= stmt_list last_stmt SEMICOLON .

stmt ::= expr_call . [PREFER_CALL]
stmt ::= stmt_assign .
stmt ::= definition .
stmt ::= VAR name_list .
stmt ::= VAR name_list ASSIGN assign_rval .
stmt ::= YIELD unpack_list .
stmt ::= YIELD FOR expr_call . [PREFER_CALL]
stmt ::= THROW expr .
stmt ::= DO block END .
stmt ::= IF expr THEN block elif_list_opt else_opt END .
stmt ::= FOR name_list ASSIGN expr COLON expr step_opt DO block END .
stmt ::= FOR name_list COLON expr DO block END .
stmt ::= WHILE expr DO block END .
stmt ::= REPEAT block UNTIL expr .
stmt ::= RETURN unpack_list .
stmt ::= BREAK .
stmt ::= CONTINUE .

elif_list_opt ::= .
elif_list_opt ::= elif_list_opt ELIF expr THEN block .

else_opt ::= .
else_opt ::= ELSE block .

step_opt ::= .
step_opt ::= COLON expr .

name_list ::= IDENTIFIER .
name_list ::= name_list COMMA IDENTIFIER .

last_stmt ::= RETURN .

stmt_assign ::= lval_list op_assign assign_rval .

assign_rval ::= unpack_list .
assign_rval ::= YIELD unpack_list .
assign_rval ::= YIELD FOR expr_call . [PREFER_CALL]
assign_rval ::= YIELD FOR expr_call ELLIPSIS .
assign_rval ::= unpack_list /* lval_list */ op_assign assign_rval .

op_assign ::= ASSIGN .
op_assign ::= MUL_ASSIGN .
op_assign ::= DIV_ASSIGN .
op_assign ::= INTDIV_ASSIGN .
op_assign ::= MOD_ASSIGN .
op_assign ::= ADD_ASSIGN .
op_assign ::= SUB_ASSIGN .
op_assign ::= CONCAT_ASSIGN .
op_assign ::= LSHIFT_ASSIGN .
op_assign ::= RSHIFT_ASSIGN .
op_assign ::= ASHIFT_ASSIGN .
op_assign ::= BITAND_ASSIGN .
op_assign ::= BITXOR_ASSIGN .
op_assign ::= BITOR_ASSIGN .


// EXPRESSIONS

%type expr_lval { expr_type }
%type lval_list { expr_type }
%type expr_prefix { expr_type }
%type expr_call { expr_type }
%type expr_literal { expr_type }
%type expr_unary { expr_type }
%type expr_muldiv { expr_type }
%type expr_addsub { expr_type }
%type expr_shift { expr_type }
%type expr_bitand { expr_type }
%type expr_bitxor { expr_type }
%type expr_bitor { expr_type }
%type expr_compare { expr_type }
%type expr_not { expr_type }
%type expr_and { expr_type }
%type expr_or { expr_type }
%type expr { expr_type }
%type unpack_list_opt { expr_type }
%type unpack_list { expr_type }
%type term_list { expr_type }

expr_lval(x) ::= IDENTIFIER(tok) .
    {
        x = { EXPR_NAME, p->string_node( AST_EXPR_IDENTIFIER, tok.sloc, tok.text, tok.size ) };
    }
expr_lval(x) ::= expr_prefix(u) PERIOD(op) IDENTIFIER(tok) .
    {
        p->string_node( AST_EXPR_IDENTIFIER, tok.sloc, tok.text, tok.size );
        x = { EXPR_LVAL, p->node( AST_EXPR_KEY, op.sloc, u.index ) };
    }
expr_lval(x) ::= expr_prefix(u) LSQ(op) expr RSQ .
    {
        x = { EXPR_LVAL, p->node( AST_EXPR_INDEX, op.sloc, u.index ) };
    }

lval_list(x) ::= expr_lval(u) . { x = u; }
lval_list(x) ::= lval_list(u) COMMA expr_lval(v) .
    {
        // Check if it's a name list.
        expr_kind k = EXPR_NAME_LIST;
        if ( u.kind != EXPR_NAME && u.kind != EXPR_NAME_LIST ) k = EXPR_LVAL_LIST;
        if ( v.kind != EXPR_NAME ) k = EXPR_LVAL_LIST;
        x = u;
    }

expr_prefix(x) ::= expr_lval(u) .                               { x = u; }
expr_prefix(x) ::= expr_call(u) . [LPN]                         { x = u; }
expr_prefix(x) ::= LPN expr(u) RPN .                            { x = { EXPR_FULL, u.index }; }

expr_call(x) ::= expr_prefix(u) LPN(op) unpack_list_opt RPN .   { x = { EXPR_CALL, p->node( AST_EXPR_CALL, op.sloc, u.index ) }; }

expr_literal(x) ::= expr_prefix(u) . [PREFER_CALL]              { x = u; }
expr_literal(x) ::= NULL(tok) .                                 { x = { EXPR_FULL, p->node( AST_EXPR_NULL, tok.sloc, p->no_child() ) }; }
expr_literal(x) ::= FALSE(tok) .                                { x = { EXPR_FULL, p->node( AST_EXPR_FALSE, tok.sloc, p->no_child() ) }; }
expr_literal(x) ::= TRUE(tok) .                                 { x = { EXPR_FULL, p->node( AST_EXPR_TRUE, tok.sloc, p->no_child() ) }; }
expr_literal(x) ::= NUMBER(tok) .                               { x = { EXPR_FULL, p->number_node( AST_EXPR_NUMBER, tok.sloc, tok.n ) }; }
expr_literal(x) ::= STRING(tok) .                               { x = { EXPR_FULL, p->string_node( AST_EXPR_STRING, tok.sloc, tok.text, tok.size ) }; }

expr_unary(x) ::= expr_literal(u) .                             { x = u; }
expr_unary(x) ::= HASH(op) expr_unary(u) .                      { x = { EXPR_FULL, p->node( AST_EXPR_LENGTH, op.sloc, u.index ) }; }
expr_unary(x) ::= MINUS(op) expr_unary(u) .                     { x = { EXPR_FULL, p->node( AST_EXPR_NEG, op.sloc, u.index ) }; }
expr_unary(x) ::= PLUS(op) expr_unary(u) .                      { x = { EXPR_FULL, p->node( AST_EXPR_POS, op.sloc, u.index ) }; }
expr_unary(x) ::= TILDE(op) expr_unary(u) .                     { x = { EXPR_FULL, p->node( AST_EXPR_BITNOT, op.sloc, u.index ) }; }

expr_muldiv(x) ::= expr_unary(u) .                              { x = u; }
expr_muldiv(x) ::= expr_muldiv(u) ASTERISK(op) expr_unary .     { x = { EXPR_FULL, p->node( AST_EXPR_MUL, op.sloc, u.index ) }; }
expr_muldiv(x) ::= expr_muldiv(u) SOLIDUS(op) expr_unary .      { x = { EXPR_FULL, p->node( AST_EXPR_DIV, op.sloc, u.index ) }; }
expr_muldiv(x) ::= expr_muldiv(u) INTDIV(op) expr_unary .       { x = { EXPR_FULL, p->node( AST_EXPR_INTDIV, op.sloc, u.index ) }; }
expr_muldiv(x) ::= expr_muldiv(u) PERCENT(op) expr_unary .      { x = { EXPR_FULL, p->node( AST_EXPR_MOD, op.sloc, u.index ) }; }

expr_addsub(x) ::= expr_muldiv(u) .                             { x = u; }
expr_addsub(x) ::= expr_addsub(u) PLUS(op) expr_muldiv .        { x = { EXPR_FULL, p->node( AST_EXPR_ADD, op.sloc, u.index ) }; }
expr_addsub(x) ::= expr_addsub(u) MINUS(op) expr_muldiv .       { x = { EXPR_FULL, p->node( AST_EXPR_SUB, op.sloc, u.index ) }; }
expr_addsub(x) ::= expr_addsub(u) TILDE(op) expr_muldiv .       { x = { EXPR_FULL, p->node( AST_EXPR_CONCAT, op.sloc, u.index ) }; }

expr_shift(x) ::= expr_addsub(u) .                              { x = u; }
expr_shift(x) ::= expr_shift(u) LSHIFT(op) expr_addsub .        { x = { EXPR_FULL, p->node( AST_EXPR_LSHIFT, op.sloc, u.index ) }; }
expr_shift(x) ::= expr_shift(u) RSHIFT(op) expr_addsub .        { x = { EXPR_FULL, p->node( AST_EXPR_RSHIFT, op.sloc, u.index ) }; }
expr_shift(x) ::= expr_shift(u) ASHIFT(op) expr_addsub .        { x = { EXPR_FULL, p->node( AST_EXPR_ASHIFT, op.sloc, u.index ) }; }

expr_bitand(x) ::= expr_shift(u) .                              { x = u; }
expr_bitand(x) ::= expr_bitand(u) AMPERSAND(op) expr_shift .    { x = { EXPR_FULL, p->node( AST_EXPR_BITAND, op.sloc, u.index ) }; }

expr_bitxor(x) ::= expr_bitand(u) .                             { x = u; }
expr_bitxor(x) ::= expr_bitxor(u) CARET(op) expr_bitand .       { x = { EXPR_FULL, p->node( AST_EXPR_BITXOR, op.sloc, u.index ) }; }

expr_bitor(x) ::= expr_bitxor(u) .                              { x = u; }
expr_bitor(x) ::= expr_bitor(u) VBAR(op) expr_bitxor .          { x = { EXPR_FULL, p->node( AST_EXPR_BITOR, op.sloc, u.index ) }; }

expr_compare(x) ::= expr_bitor(u) .                             { x = u; }
expr_compare(x) ::= expr_compare(u) op_compare expr_bitor .     { x = { EXPR_FULL, p->node( AST_EXPR_COMPARE, p->node_sloc( u.index ), u.index ) }; }

op_compare(x) ::= EQ(op) .                                      { x = p->node( AST_OP_EQ, op.sloc, p->no_child() ); }
op_compare(x) ::= NE(op) .                                      { x = p->node( AST_OP_NE, op.sloc, p->no_child() ); }
op_compare(x) ::= LT(op) .                                      { x = p->node( AST_OP_LT, op.sloc, p->no_child() ); }
op_compare(x) ::= LE(op) .                                      { x = p->node( AST_OP_LE, op.sloc, p->no_child() ); }
op_compare(x) ::= GT(op) .                                      { x = p->node( AST_OP_GT, op.sloc, p->no_child() ); }
op_compare(x) ::= GE(op) .                                      { x = p->node( AST_OP_GE, op.sloc, p->no_child() ); }
op_compare(x) ::= IS(op) .                                      { x = p->node( AST_OP_IS, op.sloc, p->no_child() ); }
op_compare(x) ::= IS(op) NOT .                                  { x = p->node( AST_OP_IS_NOT, op.sloc, p->no_child() ); }

expr_not(x) ::= expr_compare(u) .                               { x = u; }
expr_not(x) ::= NOT(op) expr_not(u) .                           { x = { EXPR_FULL, p->node( AST_EXPR_NOT, op.sloc, u.index ) }; }

expr_and(x) ::= expr_not(u) .                                   { x = u; }
expr_and(x) ::= expr_and(u) AND(op) expr_not .                  { x = { EXPR_FULL, p->node( AST_EXPR_AND, op.sloc, u.index ) }; }

expr_or(x) ::= expr_and(u) .                                    { x = u; }
expr_or(x) ::= expr_or(u) OR(op) expr_and .                     { x = { EXPR_FULL, p->node( AST_EXPR_OR, op.sloc, u.index ) }; }

expr_if ::= IF expr_or THEN expr expr_elif_list_opt ELSE expr .

expr_elif_list_opt ::= .
expr_elif_list_opt ::= expr_elif_list_opt ELIF expr THEN expr .

expr ::= expr_if .
expr ::= constructor .

unpack_list_opt ::= .
unpack_list_opt ::= unpack_list .

unpack_list ::= term_list .
unpack_list ::= term_list ELLIPSIS .

term_list ::= expr .
term_list ::= term_list COMMA expr .


// CONSTRUCTOR EXPRESSIONS

constructor ::= DEF LPN parameters RPN lambda_body .
constructor ::= DEF YIELD LPN parameters RPN lambda_body .
constructor ::= DEF prototype_opt object_keys END .
constructor ::= LSQ unpack_list_opt RSQ .
constructor ::= LBR keyval_list_opt RBR .

lambda_body ::= COLON expr .
lambda_body ::= block END .

parameters ::= .
parameters ::= param_list .
parameters ::= param_list ELLIPSIS .

param_list ::= IDENTIFIER .
param_list ::= param_list COMMA IDENTIFIER .

keyval_list_opt ::= .
keyval_list_opt ::= keyval_list_opt COMMA keyval .

keyval ::= expr COLON expr .


// DEFINITIONS

definition ::= DEF qual_name LPN parameters RPN block END .
definition ::= DEF YIELD qual_name LPN parameters RPN block END .
definition ::= DEF qual_name prototype_opt object_keys END .

qual_name ::= IDENTIFIER .
qual_name ::= qual_name PERIOD IDENTIFIER .

prototype_opt ::= .
prototype_opt ::= IS expr .

object_keys ::= .
object_keys ::= object_keys object_key .

object_key ::= IDENTIFIER COLON expr .
object_key ::= IDENTIFIER COLON expr SEMICOLON .
object_key ::= definition .


// TRY CATCH
/*
stmt ::= WITH unpack_list DO block END .
stmt ::= WITH unpack_list /* name_list *//* ASSIGN unpack_list DO block END .
stmt ::= TRY block catch_list_opt finally_opt END .

catch_list_opt ::= .
catch_list_opt ::= catch_list_opt catch .

catch ::= CATCH IDENTIFIER THEN block .
catch ::= CATCH IDENTIFIER IS expr THEN block .

finally_opt ::= FINALLY block .
*/

