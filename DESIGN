kenaf is a lua-like language with a prototype-based object model.
it is designed to be as simple as possible.

a call x.y always passes x as first argument
a definition x.y declares 'self', and 'super' as 'superof( self )'

bare functions and lambdas don't have automatic self.

unpacking is not automatic.  varargs is a special value that can be unpacked.

    def f( args ... )
        a, b, c = f()       -- error, not enough values
        a, b, c = f() ...   -- ok, unpacks 3 results from f
        a, b, c = args      -- error, args isn't a real value
        a, b, c = args ...  -- ok
        a = [ args ... ]    -- unpacking allowed in array construction
        f( "x", args ... )  -- and in argument lists
        b, c, z = 3, a ...  -- ok, unpacks array
    end

comparisons are chained like in python

    if not 0 <= index < size then
    end

lenght operator, like lua

    for i = 0, #array do
    end

bitwise operators, including shifts

    a << b  left
    a >> b  logical right
    a ~>> b arithmetic right

tables and arrays

    var table = { 'key' : value }
    var array = [ a, b, c ]

objects:

    def object
        key : value
        key : value
        def method()
        end
    end

    def object is prototype
        def self( p, q )
        end
    end

    var x = object( p, q )

prototype rules:

    once object has been used as a prototype, it's sealed and no keys can be
    added to it.

    primitive values, including bools, numbers, strings, functions, and
    generators/cothreads cannot be used as prototypes

functions:

    def function()
    end

out-of-line methods:

    def object end
    def object.method()
    end

lambdas

    var lambda = def() return x end
    var lambda = def() : x

generators must be marked with yield:

    def yield coroutine( param, param )
        param, param = yield expr, expr
        return
    end
    var lambda = def yield( param ) return y end

calling a generator function produces a generator

to delegate to a child generator use 'yield for'

    yield for subgenerator()

statements

    a, b = b, a = c, d = e, f
    a = b *= c
    f()
    break
    continue
    return
    yield
    throw
    do
    end
    if expr then
    elif expr then
    end
    for i = start : stop do
    end
    for i = start : stop : step do
    end
    for k, v : generator do
    end
    while expr do
    end
    repeat
    until expr


builtins:

    global

    superof( object )
    haskey( object, string ) -> bool
    getkey( object, string ) -> value
    setkey( object, string, value ) -> value
    delkey( object, string )
    keys( object ) -> generator

    abs( n )
    max( n ... )
    min( n ... )
    pow( n, n )
    sqrt( n )
    sin( n )
    tan( n )
    cos( n )
    asin( n )
    acos( n )
    atan( n[, n ] )
    ceil( n )
    trunc( n )
    floor( n )
    round( n )
    isnan( n )
    isinf( n )
    isfinite( n )

    pi
    tau
    nan
    infinity

    def object
    end

    def bool is object
    end

    def number is object
        def self( o ) return string_to_number( o ) end
    end

    def string is object
        def self( o ) return object_to_string( o ) end
    end

    def array is object
        def resize( n ) end
        def append( x ) end
        def extend( x ... ) end
        def pop() return x end
    end

    def table is object
        def get( k, default )
        def del( k )
    end


extras, for the future.  don't need to catch exceptions necessarily to start
with.

    with exprlist do
    end
    with name, name = exprlist do
    end
    try
    catch name is prototype then
    catch name then
    finally
    end




VM

    nun-boxing

        0000'0000'0000'0000
        0000'FFFF'FFFF'FFFF kn::object*

        000F'FFFF'FFFF'FFFF first double
        000F'FFFF'FFFF'FFFF -∞
        7FFF'FFFF'FFFF'FFFF -0
        8007'FFFF'FFFF'FFFE qNAN
        800F'FFFF'FFFF'FFFE sNaN
        800F'FFFF'FFFF'FFFF +∞
        FFFF'FFFF'FFFF'FFFF +0


    kv::selector
        kv::string* key

