//
//  source.h
//
//  Created by Edmund Kapusniak on 28/09/2019.
//  Copyright Â© 2019 Edmund Kapusniak.
//
//  Licensed under the MIT License. See LICENSE file in the project root for
//  full license information.
//

#ifndef KF_SOURCE_H
#define KF_SOURCE_H

#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <string>
#include <vector>
#include <memory>
#include "kenaf/compiler.h"

namespace kf
{

/*
    Source locations are stored everywhere as small integers, and mapped to a
    line/column pair by consulting the newline table.
*/

typedef uint32_t srcloc;

struct source_location
{
    unsigned line;
    unsigned column;
};

struct source_string
{
    size_t size;
    const char text[ 1 ];
};

struct source_string_deleter { void operator () ( void* p ) const { free( p ); } };
typedef std::unique_ptr< source_string, source_string_deleter > source_string_ptr;

/*
    Diagnostics.
*/

struct source_diagnostic
{
    diagnostic_kind kind;
    source_location location;
    std::string message;
};

/*
    Computers are not hurting for memory.  A source object holds:

      - The entire source text of a script.
      - A buffer of character offsets identifying the start of each line.
      - The text of strings lexed from the script, or used as constants.
      - A list of diagnostics generated by the parsing process.

    Source text has SOURCE_LOOKAHEAD null characters at the end of the text.
    This simplifies lexing.
*/

const size_t SOURCE_LOOKAHEAD = 4;

struct source
{
    source();
    ~source();

    void append( const void* data, size_t size );
    void* buffer( size_t size );
    size_t size() const;

    void newline( srcloc sloc );
    source_location location( srcloc sloc ) const;

    const source_string* new_string( const char* text, size_t size );
    const source_string* new_string( const char* atext, size_t asize, const char* btext, size_t bsize );

    std::string path;
    std::vector< char > text;
    std::vector< srcloc > newlines;
    std::vector< source_string_ptr > strings;

};

struct errors
{
    errors();
    ~errors();

    void reset();

    std::vector< source_diagnostic > diagnostics;
    bool has_error;
};

struct report
{
    report( struct source* source, errors* errors );
    ~report();

    void error( srcloc sloc, const char* message, ... ) KF_PRINTF_FORMAT( 3, 4 );
    void error( srcloc sloc, const char* message, va_list ap );
    void warning( srcloc sloc, const char* message, ... ) KF_PRINTF_FORMAT( 3, 4 );
    void warning( srcloc sloc, const char* message, va_list ap );
    void diagnostic( diagnostic_kind kind, srcloc sloc, const char* message, va_list ap );

    struct source* source;
    struct errors* errors;
};

}

#endif

