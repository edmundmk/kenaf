//
//  source.h
//
//  Created by Edmund Kapusniak on 28/09/2019.
//  Copyright Â© 2019 Edmund Kapusniak.
//
//  Licensed under the MIT License. See LICENSE file in the project root for
//  full license information.
//

#ifndef SOURCE_H
#define SOURCE_H

#include <stdlib.h>
#include <stdint.h>
#include <string>
#include <vector>

#if defined( __GNUC__ )
#define PRINTF_FORMAT( x, y ) __attribute__(( format( printf, x, y ) ))
#else
#define PRINTF_FORMAT( x, y )
#endif

namespace kf
{

/*
    Source locations are stored everywhere as small integers, and mapped to a
    line/column pair by consulting the newline table.
*/

typedef uint32_t srcloc;

struct source_location
{
    unsigned line;
    unsigned column;
};

struct source_string
{
    const char* text;
    size_t size;
};

/*
    Diagnostic messages are stored along with the text.
*/

enum source_diagnostic_kind
{
    ERROR,
};

struct source_diagnostic
{
    source_diagnostic_kind kind;
    source_location line_info;
    std::string message;
};

/*
    Computers are not hurting for memory.  A source object holds:

      - The entire source text of a script.
      - A buffer of character offsets identifying the start of each line.
      - The text of strings lexed from the script.
      - A list of diagnostics generated by the parsing process.

    Source text has SOURCE_LOOKAHEAD null characters at the end of the text.
    This simplifies lexing.
*/

const size_t SOURCE_LOOKAHEAD = 4;

struct source
{
    source();
    ~source();

    void append( void* data, size_t size );
    size_t size() const;

    void newline( srcloc sloc );
    source_location location( srcloc sloc ) const;

    void error( srcloc sloc, const char* message, ... ) PRINTF_FORMAT( 3, 4 );

    std::string filename;
    std::vector< char > text;
    std::vector< srcloc > newlines;
    std::vector< source_string > strings;
    std::vector< source_diagnostic > diagnostics;
};

}

#endif

